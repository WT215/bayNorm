{
    "collab_server" : "",
    "contents" : "#include <RcppArmadillo.h>\n#include <RcppArmadilloExtensions/sample.h>\n#include <Rmath.h>\n#include <Rcpp.h>\n// [[Rcpp::depends(RcppArmadillo)]]\n\nusing namespace Rcpp ;\nusing namespace arma;\nusing namespace std;\n\n\nstruct add_multiple {\n  int incr;\n  int count;\n  add_multiple(int incr)\n    : incr(incr), count(0)\n  {}\n  inline int operator()(int d) {\n    return d + incr * count++;\n  }\n};\n\nRcpp::NumericVector rcpp_seq(double from_, double to_, double by_ = 1.0) {\n  int adjust = std::pow(10, std::ceil(std::log10(10 / by_)) - 1);\n  int from = adjust * from_;\n  int to = adjust * to_;\n  int by = adjust * by_;\n\n  std::size_t n = ((to - from) / by) + 1;\n  Rcpp::IntegerVector res = Rcpp::rep(from, n);\n  add_multiple ftor(by);\n\n  std::transform(res.begin(), res.end(), res.begin(), ftor);\n  return Rcpp::NumericVector(res) / adjust;\n}\n\n\ndouble chooseC(double n, double k) {\n  return Rf_choose(n, k);\n}\n\n\n\n\ndouble compute_prob2(double n, double m, double beta) {\n  double prob;\n  arma::vec k = arma::linspace<vec>(0, m-1, m);\n  arma::vec k_vec;\n\n  if(n<m){prob=0;}\n  else{\n    if(chooseC(n,m)==R_PosInf){\n\n      k_vec= (n-k)/(m-k)*pow((1-beta),(n-m)/m)*beta;\n\n      prob=arma::prod(k_vec)*beta;\n    }\n    else{\n      prob = beta * chooseC(n,m) * pow(beta,m) * pow((1-beta),(n-m));\n    }\n\n  }\n  return(prob);\n}\n\n\n\n\ndouble compute_prob_prior2(double n, double m,  double beta, double size, double m_ave) {\n  double prob;\n  arma::vec k = arma::linspace<vec>(0, m-1, m);\n  arma::vec k_vec;\n\n  if(n<m){prob=0;}\n  else{\n\n    if(chooseC(n,m)==R_PosInf){\n\n      k_vec= (n-k)/(m-k)*pow((1-beta),(n-m)/m)*beta;\n\n      prob=prod(k_vec)*beta*dnbinom_mu(n,size,m_ave,0);\n    }\n\n    else{\n      prob = beta *chooseC(n,m) * pow(beta,m) * pow((1-beta),(n-m))*dnbinom_mu(n, size, m_ave, 0);\n    }\n\n  }\n  return(prob);\n\n}\n\n\n\n\n\nNumericVector Compute2function(IntegerVector x,double m,double beta,double size, double m_ave, int last,int Indicate) {\n\n\n  NumericVector y(last+1);\n\n  if(Indicate==1)\n  {\n    for(int temp=0;temp<(last+1);temp++){\n      y(temp)=compute_prob_prior2(x(temp), m, beta, size, m_ave);\n    }\n  }\n\n  else{\n    for(int temp2=0;temp2<(last+1);temp2++){\n      y(temp2)=compute_prob2(x(temp2), m, beta);\n    }\n  }\n  return(y);\n}\n\n\nNumericVector Compute2function_norm(IntegerVector x,double m,double beta,int last, int init) {\n\n  NumericVector y(last-init+1);\n\n    for(int temp2=0;temp2<(last-init+1);temp2++){\n      y(temp2)=R::dnorm(m,x(temp2)*beta,x(temp2)*beta*(1- beta),false);\n    }\n  return(y);\n}\n\n\n//' Main_Bay\n//'\n//' bayNorm\n//' If the observed count is above 500, we then used normal distribution to approximate binomial distribution.\n//'\n//'\n//' @param Data: raw count Data\n//' @param BETA_vec: A vector of capture efficiencies of cells\n//' @param size: A vector of size\n//' @param mu: A vector of mu\n//' @param S: number of samples that you want to generate\n//' @param thres:thres\n//' @param Mean_depth:Mean_depth\n//' @return bayNorm\n//' @export\n// [[Rcpp::export]]\nNumericVector Main_Bay(NumericMatrix Data, NumericVector BETA_vec, NumericVector size, Nullable<NumericVector> mu,int S,int thres,double Mean_depth)\n{\n\n\n\n  arma::mat M = Rcpp::as<arma::mat>(Data);\n\n  arma::vec Beta = Rcpp::as<arma::vec>(BETA_vec);\n  arma::vec M_ave;\n  arma::mat M_t;\n\n  int nrow=M.n_rows;\n  int ncol=M.n_cols;\n  int i;\n  int j;\n  int q;\n  int dim;\n\n  int last;\n  int init;\n  int NormalApproThre=500;\n\n  IntegerVector x;\n  NumericVector y;\n\n  arma::cube Final_mat(nrow, ncol, S);\n\n\n  if (mu.isNotNull())\n  {\n\n    M_ave = Rcpp::as<arma::vec>(mu);\n  }\n\n\n  else{\n\n    arma::rowvec M_colmean=arma::sum(M, dim=0 );\n\n    M_t=M.each_row() / M_colmean;\n    M_ave = arma::mean(M_t, dim=1 )*Mean_depth;\n  }\n\n\n  for( i=0;i<ncol;i++){\n    Rcout << \"The cell is \\n\" << i+1 << std::endl;\n\n    for( j=0;j<nrow;j++){\n\n      //if(debug)\n      //{Rcout << \"The gene is \\n\" << j+1 << std::endl;}\n\n      if(M(j,i)==NA_INTEGER) {\n        for( q=0;q<S;q++){Final_mat(j,i,q)=NA_INTEGER;}\n      }\n\n      else{\n\n        if(M(j,i)<NormalApproThre){\n      last=floor((M(j,i)+1)*3/Beta(i));\n      x=(seq_len(last+1)-1);\n\n        if(M(j,i)<thres){\n\n          y=Compute2function(x,M(j,i),Beta(i),size(j), M_ave(j), last,1);\n        }\n\n        else{\n          y=Compute2function(x,M(j,i),Beta(i),size(j), M_ave(j), last,0);\n        }\n        }else{\n          init=M(j,i)/3/Beta(i);\n          last=M(j,i)*3/Beta(i);\n          x=rcpp_seq(init,last,1);\n           y=Compute2function_norm(x,M(j,i),Beta(i),last,init);\n\n        }\n\n        NumericVector z=y/sum(y);\n\n\n        //Rcout << \"The gene is \\n\" << j+1 << std::endl;\n        IntegerVector S_temp=Rcpp::RcppArmadillo::sample(x, S, true, z);\n        arma::vec S_input = Rcpp::as<arma::vec>(S_temp);\n        Final_mat.subcube(j,i,0,j,i,S-1)=S_input;\n\n\n      } //end of else\n\n\n    } //j\n\n  }  //i\n\n\n  NumericVector Final_mat2=Rcpp::wrap(Final_mat);\n  Rcpp::rownames(Final_mat2) = Rcpp::rownames(Data);\n  Rcpp::colnames(Final_mat2) = Rcpp::colnames(Data);\n\nreturn(Rcpp::wrap(Final_mat2));\n}\n\n\n//' Mode_Bay\n//'\n//' bayNorm\n//' If the observed count is above 500, we then used normal distribution to approximate binomial distribution.\n//'\n//'\n//' @param Data: raw count Data\n//' @param BETA_vec: A vector of capture efficiencies of cells\n//' @param size: A vector of size\n//' @param mu: A vector of mu\n//' @param S: number of samples that you want to generate\n//' @param thres:thres\n//' @param Mean_depth:Mean_depth\n//' @return bayNorm\n//' @export\n// [[Rcpp::export]]\nNumericMatrix Main_mode_Bay(NumericMatrix Data, NumericVector BETA_vec, NumericVector size, Nullable<NumericVector> mu,int S,int thres,double Mean_depth)\n{\n\n\n\n  arma::mat M = Rcpp::as<arma::mat>(Data);\n\n  arma::vec Beta = Rcpp::as<arma::vec>(BETA_vec);\n  arma::vec M_ave;\n  arma::mat M_t;\n\n  int nrow=M.n_rows;\n  int ncol=M.n_cols;\n  int i;\n  int j;\n  int q;\n  int dim;\n  int NormalApproThre=500;\n\n  int last;\n  int init;\n  IntegerVector x;\n  NumericVector y;\n\n  arma::mat Final_mat(nrow, ncol);\n\n\n  if (mu.isNotNull())\n  {\n\n    M_ave = Rcpp::as<arma::vec>(mu);\n  }\n\n\n  else{\n    arma::rowvec M_colmean=arma::sum(M, dim=0 );\n    M_t=M.each_row() / M_colmean;\n    M_ave = arma::mean(M_t, dim=1 )*Mean_depth;\n  }\n\n\n  for( i=0;i<ncol;i++){\n    Rcout << \"The cell is \\n\" << i+1 << std::endl;\n\n    for( j=0;j<nrow;j++){\n\n      if(M(j,i)==NA_INTEGER) {\n        for( q=0;q<S;q++){Final_mat(j,i)=NA_INTEGER;}\n      }\n\n      else{\n\n          if(M(j,i)<NormalApproThre){\n\n          last=floor((M(j,i)+1)*3/Beta(i));\n          x=(seq_len(last+1)-1);\n\n          if(M(j,i)<thres){\n\n            y=Compute2function(x,M(j,i),Beta(i),size(j), M_ave(j), last,1);\n          }\n\n          else{\n            y=Compute2function(x,M(j,i),Beta(i),size(j), M_ave(j), last,0);\n          }\n        }else{\n          init=M(j,i)/3/Beta(i);\n          last=M(j,i)*3/Beta(i);\n          x=rcpp_seq(init,last,1);\n          y=Compute2function_norm(x,M(j,i),Beta(i),last,init);\n\n        }\n\n        NumericVector z=y/sum(y);\n\n        arma::vec x_arma= Rcpp::as<arma::vec>(x);\n        arma::vec z_arma= Rcpp::as<arma::vec>(z);\n        arma::uword max_index=index_max(z_arma);\n        Final_mat(j,i)=mean(x_arma(max_index));\n\n        //Rcout << \"The gene is \\n\" << j+1 << std::endl;\n        //IntegerVector S_temp=Rcpp::RcppArmadillo::sample(x, S, true, z);\n        //arma::vec S_input = Rcpp::as<arma::vec>(S_temp);\n\n        //Final_mat.subcube(j,i,0,j,i,S-1)=S_input;\n\n      } //end of else\n\n\n    } //j\n\n  }  //i\n\n\n\n  NumericVector Final_mat2=Rcpp::wrap(Final_mat);\n  Rcpp::rownames(Final_mat2) = Rcpp::rownames(Data);\n  Rcpp::colnames(Final_mat2) = Rcpp::colnames(Data);\n\n  return(Rcpp::wrap(Final_mat2));\n}\n\n\n\n\n\n\ndouble D_SIZE(double SIZE,double MU, NumericVector m_observed,NumericVector BETA) {\n\n  NumericVector m=m_observed;\n  int nCells=m.size();\n\n  NumericVector temp_vec_2(nCells);\n\n\n  double MarginalVal;\n\n  for(int i=0;i<nCells;i++){\n\n    int last=floor((m(i)+1)*3/BETA(i));\n    NumericVector n=rcpp_seq(0,last, 1.0) ;\n    int n_length=n.size();\n    NumericVector numerator_1(n_length);\n    NumericVector numerator_2(n_length);\n    NumericVector kernel_vec(n_length);\n\n    for(int j=0;j<n_length;j++){\n\n      kernel_vec(j)=R::dbinom(m(i),n(j),BETA(i),false)*R::dnbinom_mu(n(j),SIZE,MU,false);\n      numerator_1(j)=R::digamma(n(j)+SIZE)-R::digamma(SIZE)+log(SIZE/(SIZE+MU))+(MU-n(j))/(MU+SIZE);\n      numerator_2(j)=kernel_vec(j)*numerator_1(j);\n    }\n\n\n    temp_vec_2(i)=sum(numerator_2)/sum(kernel_vec);\n\n\n  }\n\n  MarginalVal=sum(temp_vec_2);\n  return MarginalVal;\n}\n\n\n\n\ndouble D_MU(double SIZE,double MU, NumericVector m_observed,NumericVector BETA) {\n  NumericVector m=m_observed;\n  int nCells=m.size();\n  NumericVector temp_vec_2(nCells);\n  double MarginalVal;\n\n  for(int i=0;i<nCells;i++){\n\n    int last=floor((m(i)+1)*3/BETA(i));\n    NumericVector n=rcpp_seq(0,last, 1.0) ;\n    int n_length=n.size();\n    NumericVector numerator_1(n_length);\n    NumericVector numerator_2(n_length);\n    NumericVector kernel_vec(n_length);\n\n    for(int j=0;j<n_length;j++){\n\n      kernel_vec(j)=R::dbinom(m(i),n(j),BETA(i),false)*R::dnbinom_mu(n(j),SIZE,MU,false);\n      numerator_1(j)=SIZE*(n(j)-MU)/(MU*(MU+SIZE));\n      numerator_2(j)=kernel_vec(j)*numerator_1(j);\n\n    }\n    temp_vec_2(i)=sum(numerator_2);\n  }\n  MarginalVal=sum(temp_vec_2);\n  return MarginalVal;\n}\n\n\n\n\n\nNumericVector D_SIZE_MU_2D(NumericVector SIZE_MU, NumericVector m_observed,NumericVector BETA) {\n\n  NumericVector m=m_observed;\n  int nCells=m.size();\n  NumericVector temp_vec_2_SIZE(nCells);\n  NumericVector temp_vec_2_MU(nCells);\n\n  NumericVector MarginalVal_vec(2);\n\n  for(int i=0;i<nCells;i++){\n\n    int last=floor((m(i)+1)*3/BETA(i));\n    NumericVector n=rcpp_seq(0,last, 1.0) ;\n\n    int n_length=n.size();\n    NumericVector numerator_SIZE(n_length);\n    NumericVector numerator_MU(n_length);\n    NumericVector numerator_2_SIZE(n_length);\n    NumericVector numerator_2_MU(n_length);\n    NumericVector kernel_vec(n_length);\n\n    for(int j=0;j<n_length;j++){\n\n      kernel_vec(j)=R::dbinom(m(i),n(j),BETA(i),false)*R::dnbinom_mu(n(j),SIZE_MU(0),SIZE_MU(1),false);\n      numerator_SIZE(j)=R::digamma(n(j)+SIZE_MU(0))-R::digamma(SIZE_MU(0))+log(SIZE_MU(0)/(SIZE_MU(0)+SIZE_MU(1)))+(SIZE_MU(1)-n(j))/(SIZE_MU(1)+SIZE_MU(0));\n      numerator_MU(j)=SIZE_MU(0)*(n(j)-SIZE_MU(1))/(SIZE_MU(1)*(SIZE_MU(1)+SIZE_MU(0)));\n      numerator_2_SIZE(j)=kernel_vec(j)*numerator_SIZE(j);\n      numerator_2_MU(j)=kernel_vec(j)*numerator_MU(j);\n\n    }\n\n    temp_vec_2_SIZE(i)=sum(numerator_2_SIZE)/sum(kernel_vec);\n    temp_vec_2_MU(i)=sum(numerator_2_MU)/sum(kernel_vec);\n  }\n  MarginalVal_vec[0]=sum(temp_vec_2_SIZE);\n  MarginalVal_vec[1]=sum(temp_vec_2_MU);\n  return MarginalVal_vec;\n}\n\n\n\n//' GradientFun_2D\n//'\n//' GradientFun_2D\n//'\n//' @param SIZE_MU:SIZE_MU\n//' @param m_observed: m_observed\n//' @param BETA: BETA\n//' @return GradientFun_2D\n//' @export\n// [[Rcpp::export]]\nNumericVector GradientFun_2D(NumericVector SIZE_MU, NumericVector m_observed,NumericVector BETA){\n  NumericVector m=m_observed;\n  NumericVector Grad_vec(2);\n  Grad_vec=D_SIZE_MU_2D(SIZE_MU,m,BETA);\n  return Grad_vec;\n}\n\n\n\n//' MarginalF_2D\n//'\n//' MarginalF_2D\n//'\n//' @param SIZE:SIZE\n//' @param MU:MU\n//' @param size: A vector of size\n//' @param mu: A vector of mu\n//' @param m_observed:m_observed\n//' @param BETA:BETA\n//' @return Marginal likelihood\n//' @export\n// [[Rcpp::export]]\ndouble MarginalF_2D(NumericVector SIZE_MU, NumericVector m_observed, NumericVector BETA) {\n  NumericVector m=m_observed;\n  int nCells=m.size();\n  NumericVector temp_vec_2(nCells);\n\n\n  double MarginalVal;\n\n  for(int i=0;i<nCells;i++){\n\n    int last=floor((m(i)+1)*3/BETA(i));\n    NumericVector n=rcpp_seq(0,last, 1.0) ;\n    int n_length=n.size();\n    NumericVector temp_vec_1(n_length);\n\n    for(int j=0;j<n_length;j++){\n\n      temp_vec_1(j)=R::dbinom(m(i),n(j),BETA(i),false)*R::dnbinom_mu(n(j),SIZE_MU(0),SIZE_MU(1),false);\n\n    }\n\n    arma::vec temp_vec_1arma = Rcpp::as<arma::vec>(temp_vec_1);\n\n    temp_vec_2(i)=sum(temp_vec_1arma);\n\n  }\n  MarginalVal=sum(log(temp_vec_2));\n  return MarginalVal;\n}\n\n\n//1D optimization\n\n\n\ndouble D_SIZE_MU_1D(double SIZE,double MU, NumericVector m_observed,NumericVector BETA) {\n\n  NumericVector m=m_observed;\n  int nCells=m.size();\n  NumericVector temp_vec_2_SIZE(nCells);\n  NumericVector temp_vec_2_MU(nCells);\n\n  double MarginalVal;\n\n  for(int i=0;i<nCells;i++){\n\n    int last=floor((m(i)+1)*3/BETA(i));\n    NumericVector n=rcpp_seq(0,last, 1.0) ;\n    int n_length=n.size();\n    NumericVector numerator_SIZE(n_length);\n    NumericVector numerator_MU(n_length);\n    NumericVector numerator_2_SIZE(n_length);\n    NumericVector numerator_2_MU(n_length);\n    NumericVector kernel_vec(n_length);\n\n    for(int j=0;j<n_length;j++){\n\n      kernel_vec(j)=R::dbinom(m(i),n(j),BETA(i),false)*R::dnbinom_mu(n(j),SIZE,MU,false);\n      numerator_SIZE(j)=R::digamma(n(j)+SIZE)-R::digamma(SIZE)+log(SIZE/(SIZE+MU))+(MU-n(j))/(MU+SIZE);\n\n      numerator_2_SIZE(j)=kernel_vec(j)*numerator_SIZE(j);\n    }\n    temp_vec_2_SIZE(i)=sum(numerator_2_SIZE)/sum(kernel_vec);\n  }\n\n  MarginalVal=sum(temp_vec_2_SIZE);\n  return(MarginalVal);\n}\n\n\n\n//' GradientFun_1D\n//'\n//' GradientFun_1D\n//'\n//' @param SIZE:SIZE\n//' @param MU:MU\n//' @param m_observed: m_observed\n//' @param BETA: BETA\n//' @return GradientFun_1D\n//' @export\n// [[Rcpp::export]]\ndouble GradientFun_1D(double SIZE,double MU, NumericVector m_observed,NumericVector BETA){\n  NumericVector m=m_observed;\n  double Gradd;\n  Gradd=D_SIZE_MU_1D(SIZE, MU,m,BETA);\n  return Gradd;\n\n}\n\n\n\n//' MarginalF_1D\n//'\n//' MarginalF_1D\n//'\n//' @param SIZE:SIZE\n//' @param MU:MU\n//' @param size: A vector of size\n//' @param mu: A vector of mu\n//' @param m_observed:m_observed\n//' @param BETA:BETA\n//' @return Marginal likelihood\n//' @export\n// [[Rcpp::export]]\ndouble MarginalF_1D(double SIZE,double MU, NumericVector m_observed, NumericVector BETA) {\n  NumericVector m=m_observed;\n  int nCells=m.size();\n  NumericVector temp_vec_2(nCells);\n\n\n  double MarginalVal;\n\n  for(int i=0;i<nCells;i++){\n\n    int last=floor((m(i)+1)*3/BETA(i));\n    NumericVector n=rcpp_seq(0,last, 1.0) ;\n    int n_length=n.size();\n    NumericVector temp_vec_1(n_length);\n\n    for(int j=0;j<n_length;j++){\n      temp_vec_1(j)=R::dbinom(m(i),n(j),BETA(i),false)*R::dnbinom_mu(n(j),SIZE,MU,false);\n\n    }\n\n    arma::vec temp_vec_1arma = Rcpp::as<arma::vec>(temp_vec_1);\n\n    temp_vec_2(i)=sum(temp_vec_1arma);\n\n  }\n  MarginalVal=sum(log(temp_vec_2));\n  return MarginalVal;\n}\n\n\n",
    "created" : 1513012983177.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3597396669",
    "id" : "9DEB1587",
    "lastKnownWriteTime" : 1513175938,
    "last_content_update" : 1513175938703,
    "path" : "E:/RNAseqProject/bayNorm_dev/bayNorm/src/bayNorm_main.cpp",
    "project_path" : "src/bayNorm_main.cpp",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}
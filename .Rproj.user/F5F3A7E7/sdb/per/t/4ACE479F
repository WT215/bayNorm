{
    "collab_server" : "",
    "contents" : "\n\n#' A wrapper function of prior estimation and bayNorm function\n#'\n#' Input raw data and a vector of capture efficiencies of cells. You can\n#' also need to specify the condition of cells.\n#' @param Data: A matrix of single-cell expression where rows are genes and columns are samples (cells). This object should be of class matrix rather than data.frame.\n#' @param  BETA_vec: A vector of capture efficiencies of cells.\n#' @param S: The number of samples you would like to generate from estimated posterior distribution. Default is 20.\n#' @param  parallel: If TRUE, 5 cores will be used for parallelization.\n#' @param  NCores: number of cores to use, default is 5. This will be used to set up a parallel environment using either MulticoreParam (Linux, Mac) or SnowParam (Windows) with NCores using the package BiocParallel.\n#' @param  FIX_MU: If TRUE, then 1D optimization, otherwise 2D optimization (slow).\n#' @param  GR: If TRUE, the gradient function will be used in optimization. However since the gradient function itself is very complicated, it does not help too much in speeding up. Default is FALSE.\n#' @param  Conditions: vector of condition labels, this should correspond to the columns of the Data. Default is NULL, which assumes that all cells belong to the same group.\n#' @param  BB_SIZE: If TRUE, estimate BB size, and then use it for adjusting MME SIZE. Use the adjusted MME size for bayNorm. Defaut is TRUE.\n#' @param  mode_version: If TRUE, bayNorm return mode version normalized data which is of 2D matrix instead of 3D array. Defaut is FALSE.\n#' @param UMI: If FALSE, bayNorm assumes that the input Data is non-UMI based (full-length), hence user needs to provide scale factors for scaling the full-length dataset so that our Bayesian model still makes sense. Defaut UMI is set to be TRUE.\n#' @param sffl: (scaling factors for full-length data: divide Data by sffl) Only needed when UMI=F. If UMI=F and Conditions is non-null, then flsf should be a vector of length equal to the number of groups. Defaut is set to be NULL.\n#' @param verbose: print out status messages. Default is TRUE.\n#' @return  A list of objects.\n#'\n#' @import parallel\n#' @import foreach\n#' @import doSNOW\n#'\n#' @export\n#'\nbayNorm<-function(Data,BETA_vec,S=20,parallel=T,NCores=5,FIX_MU=T,GR=F,Conditions=NULL,BB_SIZE=T,mode_version=F,UMI=T,sffl=NULL,verbose=T){\n\n#Some pre-checkings:\n  if(class(Data)!='matrix'){stop(\"Input data should be of class matrix\")}\n  if(sum(duplicated(rownames(Data)))>0){warning(\"There are duplicated row names in Data\")}\n  if(sum(duplicated(colnames(Data)))>0){warning(\"There are duplicated column names in Data\")}\n\n\n  if(UMI==F & is.null(sffl)){stop(\"Must supply sffl (scaling factors for full-length based data).\")}\n  if(min(BETA_vec)<=0 | max(BETA_vec)>=1){stop(\"The range of BETA must be within (0,1).\")}\n  if(ncol(Data)!=length(BETA_vec)){stop(\"The number of cells (columns) in Data is not consistent with the number of elements in BETA_vec.\")}\n\n\n  if(is.null(Conditions)){\n\n    if(UMI){\n      #Data_s<-Data\n      Data_sr<-Data\n    }else{\n      Data_sr<-ceiling(Data/sffl)\n      }\n\n    PRIORS=Prior_fun(Data=Data_s,BETA_vec=BETA_vec,parallel=parallel,NCores=NCores,FIX_MU=FIX_MU,GR=GR,BB_SIZE=BB_SIZE,verbose=verbose)\n    if(BB_SIZE){\n      MU_input=PRIORS$MME_prior$MME_MU\n      SIZE_input=PRIORS$MME_SIZE_adjust\n    }else{\n      MU_input=PRIORS$MME_prior$MME_MU\n      SIZE_input=PRIORS$MME_prior$MME_SIZE\n    }\n\n    if(!mode_version){\n    Bay_array<-Main_Bay(Data=Data_sr,BETA_vec=BETA_vec,size=SIZE_input,mu=MU_input,S=S,thres=max(Data_sr)*2,Mean_depth=1000000)\n    rownames(Bay_array)<-rownames(Data)\n    colnames(Bay_array)<-colnames(Data)\n    return(list(Bay_array=Bay_array,PRIORS=PRIORS))\n    }else{ #mode\n      Bay_mat<-Main_mode_Bay(Data=Data_sr,BETA_vec=BETA_vec,size=SIZE_input,mu=MU_input,S=S,thres=max(Data_sr)*2,Mean_depth=1000000)\n      rownames(Bay_mat)<-rownames(Data)\n      colnames(Bay_mat)<-colnames(Data)\n      return(list(Bay_mat=Bay_mat,PRIORS=PRIORS))\n    }\n\n    if(verbose){\n      message(\"bayNorm has completed!\")\n    }\n\n\n  } else{# multiple groups\n\n\n\n\n   if (ncol(Data) != length(Conditions)) {stop(\"Number of columns in\n      expression matrix must match length of conditions vector!\")}\n   if(is.null(names(Conditions))) {names(Conditions) <- colnames(Data)}\n   Levels <- unique(Conditions)\n\n\n   if(UMI){#UMI\n     DataList<- lapply(seq_along(Levels), function(x){Data[,which(Conditions == Levels[x])]})\n     #DataList_s <- lapply(seq_along(Levels), function(x){Data[,which(Conditions == Levels[x])]})\n     DataList_sr <- lapply(seq_along(Levels), function(x){Data[,which(Conditions == Levels[x])]})\n\n     BETAList <- lapply(seq_along(Levels), function(x){BETA_vec[which(Conditions == Levels[x])]})\n   }else{#non-UMI\n     DataList<- lapply(seq_along(Levels), function(x){Data[,which(Conditions == Levels[x])]})\n     DataList_sr <- lapply(seq_along(Levels), function(x){ceiling(Data[,which(Conditions == Levels[x])]/sffl[x])})\n     BETAList <- lapply(seq_along(Levels), function(x){BETA_vec[which(Conditions == Levels[x])]})\n   }\n\n   PRIORS_LIST<-list()\n   for(i in 1:length(Levels)){\n     PRIORS_LIST[[i]]<-Prior_fun(Data=DataList_sr[[i]],BETA_vec=BETAList[[i]],parallel=parallel,NCores=NCores,FIX_MU=FIX_MU,GR=GR,BB_SIZE=BB_SIZE,verbose=verbose)\n     if(BB_SIZE){\n       MU_input=PRIORS_LIST[[i]]$MME_prior$MME_MU\n       SIZE_input=PRIORS_LIST[[i]]$MME_SIZE_adjust\n     }else{\n       MU_input=PRIORS_LIST[[i]]$MME_prior$MME_MU\n       SIZE_input=PRIORS_LIST[[i]]$MME_prior$MME_SIZE\n     }\n   }\n   names(PRIORS_LIST)<-paste('Group',Levels)\n\n\n   if(!mode_version){\n   Bay_array_list<-list()\n   for(i in 1:length(Levels)){\n     Bay_array_list[[i]]<-Main_Bay(Data=DataList_sr[[i]],BETA_vec=BETAList[[i]],size=SIZE_input,mu=MU_input,S=S,thres=max(Data)*2,Mean_depth=1000000,debug=F)\n\n     rownames(Bay_array_list[[i]])<-rownames(DataList[[i]])\n     colnames(Bay_array_list[[i]])<-colnames(DataList[[i]])\n   }\n   names(Bay_array_list)<-paste('Group',Levels)\n   return(list(Bay_array_list=Bay_array_list,PRIORS_LIST=PRIORS_LIST))\n   }else{#mode\n\n     Bay_mat_list<-list()\n     for(i in 1:length(Levels)){\n       Bay_mat_list[[i]]<-Main_mode_Bay(Data=DataList_sr[[i]],BETA_vec=BETAList[[i]],size=SIZE_input,mu=MU_input,S=S,thres=max(Data)*2,Mean_depth=1000000)\n\n       rownames(Bay_mat_list[[i]])<-rownames(DataList[[i]])\n       colnames(Bay_mat_list[[i]])<-colnames(DataList[[i]])\n     }\n     names(Bay_mat_list)<-paste('Group',Levels)\n     return(list(Bay_mat_list=Bay_mat_list,PRIORS_LIST=PRIORS_LIST))\n\n   } #end of mode for multiple groups\n }# end for multiple groups\n\n  if(verbose){\n    message(\"bayNorm has completed!\")\n  }\n\n}\n\n\n\n",
    "created" : 1513012775556.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3357631219",
    "id" : "4ACE479F",
    "lastKnownWriteTime" : 1513178357,
    "last_content_update" : 1513178357482,
    "path" : "E:/RNAseqProject/bayNorm_dev/bayNorm/R/bayNorm.r",
    "project_path" : "R/bayNorm.r",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}
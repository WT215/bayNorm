#' @title newQQParams (adapted from Splatter)
#'
#' @description  Initializing an object for storing parameters for simulating scRNAseq data.
#'
#' @param update default NULL
#'
#' @examples
#' data('EXAMPLE_DATA_list')
#' \dontrun{
#' }
#'
#' @export
newQQParams <- function(update = NULL,...) {

    params <- new("QQParams")
    checkmate::assertList(update, null.ok = TRUE)
    update <- c(update, list(...))

    if (length(update) > 0) {
        for (name in names(update)) {
            value <- update[[name]]
            slot( params ,name) <- value
        }
    }
    validObject( params)
    return(  params)
}


#' @title QQinitiate (adapted from Splatter)
#'
#' @description  Initializing SingleCellExperiment object.
#'
#' @param Est_params Object storing parameters needed for simulation.
#'
#' @examples
#' data('EXAMPLE_DATA_list')
#' \dontrun{
#' }
#'
#' @export
QQinitiate<-function(Est_params){
    nGenes <- Est_params@nGenes
    nCells<-ifelse(Est_params@nGroups==1,Est_params@nCells,sum(Est_params@groupCells))
    cell.names <- paste0("Cell", seq_len(nCells))
    gene.names <- paste0("Gene", seq_len(nGenes))


    cells <-  data.frame(Cell = cell.names)
    rownames(cells) <- cell.names
    features <- data.frame(Gene = gene.names)
    rownames(features) <- gene.names

    sim <- SingleCellExperiment(rowData = features, colData = cells, metadata = list(params = params))
    return(sim)
}


#' The Params class
#' Basic class for storing parameters
#' @name Params
#' @rdname Params
#' @aliases Params-class
#' @exportClass Params
setClass("Params",
         contains = "VIRTUAL",
         slots = c(nGenes = "numeric",
                   nCells = "numeric",
                   seed = "numeric"),
         prototype = prototype(nGenes = 10000, nCells = 100,
                               seed = sample(1:1e6, 1)))
#' The QQParams class
#' QQParams class for storing parameters
#' @name Params
#' @rdname Params
#' @aliases Params-class
#' @exportClass Params
setClass("QQParams",
         contains = "Params",
         slots = c(nGroups = "numeric",
                   groupCells = "numeric",
                   mean.shape = "numeric",
                   mean.rate = "numeric",
                   lib.loc = "numeric",
                   lib.scale = "numeric",
                   beta.loc = "numeric",
                   beta.scale = "numeric",
                   out.prob = "numeric",
                   out.neg.prob= "numeric",
                   out.facLoc = "numeric",
                   out.facScale = "numeric",
                   de.prob = "numeric",
                   de.downProb = "numeric",
                   de.facLoc = "numeric",
                   de.facScale = "numeric",
                   bcv.common = "numeric",
                   bcv.df = "numeric",
                   counts.origin="matrix",
                   counts.norm.TC="matrix",
                   Genes.keep = "logical",
                   Beta="numeric",
                   MeanBeta='numeric'),
         prototype = prototype(nGroups = 1,
                               groupCells = 100,
                               mean.rate = 2.109,
                               mean.shape = 1.895,
                               lib.loc = 10.22,
                               lib.scale = 0.3779,
                               beta.loc = 10.22,
                               beta.scale = 0.3779,
                               out.prob = 0.05,
                               out.neg.prob=0,
                               out.facLoc = 2.3184,
                               out.facScale = 0.7462,
                               de.prob = 0.1,
                               de.downProb = 0.5,
                               de.facLoc = 0.1,
                               de.facScale = 0.4,
                               bcv.common = 0.1268,
                               bcv.df = 60,
                               MeanBeta=0.07
         ))

#' @title QQ_Est
#'
#' @description  Perform library size normalization.
#'
#' @param counts Input raw data
#' @param Params object storing parameters
#'
#' @examples
#' data('EXAMPLE_DATA_list')
#' \dontrun{
#' }
#'
#' @export
QQ_Est <- function(counts,Params) {
    Params<-new("QQParams")
    # Normalise for library size and remove all zero genes
    lib.sizes <- colSums(counts)
    lib.med <- median(lib.sizes)
    norm.counts <- t(t(counts) / lib.sizes * lib.med)
    norm.counts <- norm.counts[rowSums(norm.counts > 0) > 1, ]

    keep_logit<-rowSums(norm.counts > 0) > 1

    Params@counts.origin<-counts
    Params@counts.norm.TC<-norm.counts
    Params@nGenes<-nrow(counts)
    Params@nCells<-ncol(counts)
    Params@Genes.keep<-keep_logit

    return(Params)
}

#' Winsorize vector (adapted from Splatter)
#'
#' Set outliers in a numeric vector to a specified percentile.
#'
#' @param x Numeric vector to winsorize
#' @param q Percentile to set from each end
#'
#' @return Winsorized numeric vector
winsorize <- function(x, q) {

    checkmate::check_numeric(x, any.missing = FALSE)
    checkmate::check_number(q, lower = 0, upper = 1)

    lohi <- stats::quantile(x, c(q, 1 - q), na.rm = TRUE)

    if (diff(lohi) < 0) { lohi <- rev(lohi) }

    x[!is.na(x) & x < lohi[1]] <- lohi[1]
    x[!is.na(x) & x > lohi[2]] <- lohi[2]

    return(x)
}


#' QQEstLib (adapted from Splatter)
#'
#' A log-normal distribution is fitted and the
#' estimated parameters are added to the params object. See
#' \code{\link[fitdistrplus]{fitdist}} for details on the fitting.
#'
#' @param counts counts matrix to estimate parameters from.
#' @param params splatParams object to store estimated values in.
#'
#' @return QQParams object with estimated values.
#'
QQEstLib <- function(Est_params) {
    lib.sizes <- colSums(Est_params@counts.origin)
    fit <- fitdistrplus::fitdist(lib.sizes, "lnorm")

    Est_params@lib.loc<-unname(fit$estimate["meanlog"])
    Est_params@lib.scale<-unname(fit$estimate["sdlog"])

    return(Est_params)
}

QQEst_BETA_MEAN <- function(Est_params,inputBeta=NULL,inputMeanBeta=0.07,inputtrim=0.01) {

    counts<-Est_params@counts.origin


    if(is.null(inputBeta)){
        Trim_temp<-apply((counts),2,function(x){mean(x,trim=inputtrim)})
        Trim_beta<-Trim_temp/mean(Trim_temp)
    }
    else{
        Trim_beta<-inputBeta
    }
    #Est BETA para
    beta_fit <- fitdistrplus::fitdist(Trim_beta/inputMeanBeta, "lnorm")
    #end of BETA est

    norm.counts<-t(t(counts)/Trim_beta/inputMeanBeta)
    means <- rowMeans(norm.counts)
    means <- means[means != 0]
    means <- winsorize(means, q = 0.1)
    fit <- fitdistrplus::fitdist(means, "gamma", method = "mge",gof = "CvM")
    fit$estimate["shape"]
    fit$estimate["rate"]

    if (fit$convergence > 0) {
        warning("Goodness of fit failed, using Method of Moments")
        fit <- fitdistrplus::fitdist(means, "gamma", method = "mme")
    }


    Est_params@beta.loc<-unname(beta_fit$estimate["meanlog"])
    Est_params@beta.scale<-unname(beta_fit$estimate["sdlog"])

    Est_params@mean.shape<-unname(fit$estimate["shape"])
    Est_params@mean.rate<-unname(fit$estimate["rate"])

    Est_params@Beta<-Trim_beta
    Est_params@MeanBeta<-inputMeanBeta

    return(Est_params)
}


QQEstOutlier <- function(Est_params) {

    norm.counts<-Est_params@counts.norm.TC

    means <- rowMeans(norm.counts)
    lmeans <- log(means)
    med <- median(lmeans)
    mad <- mad(lmeans)
    bound <- med + 2 * mad
    outs <- which(lmeans > bound)
    prob <- length(outs) / nrow(norm.counts)

    if (length(outs) > 1) {
        facs <- means[outs] / median(means)
        fit <- fitdistrplus::fitdist(facs, "lnorm")}

    Est_params@out.prob<-prob
    Est_params@out.facLoc<-unname(fit$estimate["meanlog"])
    Est_params@out.facScale<- unname(fit$estimate["sdlog"])


    return( Est_params)
}




QQEstBCV <- function(Est_params) {
    # Add dummy design matrix to avoid print statement
    counts<-Est_params@counts.origin
    design <- matrix(1, ncol(counts), 1)
    disps <- edgeR::estimateDisp(counts, design = design)
    Est_params@bcv.common<-0.1 + 0.25 * disps$common.dispersion
    Est_params@bcv.df<-disps$prior.df

    return(Est_params)
}


# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Main_Bay
#'
#' bayNorm
#' If the observed count is above 500, then we use normal distribution to approximate binomial distribution.
#'
#'
#' @param Data: raw count Data
#' @param BETA_vec: A vector of capture efficiencies of cells
#' @param size: A vector of size
#' @param mu: A vector of mu
#' @param S: number of samples that you want to generate for 3D array
#' @param thres: for observed count greater than \code{thres}, use uniform prior.
#' @return bayNorm normalized data
#'
#'
#' @examples
#' \dontrun{
#' data("Main_mode_Bay_check")
#' Norm_3D_array<-Main_Bay(Data=inputdata,BETA_vec = inputbeta,
#' size=size,mu=mu,S=20,thres=10000000)
#' }
#' @export
Main_Bay <- function(Data, BETA_vec, size, mu, S, thres) {
    .Call('_bayNorm_Main_Bay', PACKAGE = 'bayNorm', Data, BETA_vec, size, mu, S, thres)
}

#' Mode_Bay
#'
#' bayNorm
#' If the observed count is above 500, then we use normal distribution to approximate binomial distribution.
#'
#'
#' @param Data: raw count Data
#' @param BETA_vec: A vector of capture efficiencies of cells
#' @param size: A vector of size
#' @param mu: A vector of mu
#' @param S: number of samples that you want to generate
#' @param thres: for observed count greater than \code{thres}, use uniform prior.
#' @return bayNorm normalized data
#'
#' //' @examples
#' \dontrun{
#' data("Main_mode_Bay_check")
#' Norm_2D_matrix<-Main_mode_Bay(Data=inputdata,BETA_vec = inputbeta,
#' size=size,mu=mu,S=20,thres=10000000)
#' }
#' @export
Main_mode_Bay <- function(Data, BETA_vec, size, mu, S, thres) {
    .Call('_bayNorm_Main_mode_Bay', PACKAGE = 'bayNorm', Data, BETA_vec, size, mu, S, thres)
}

#' GradientFun_2D
#'
#' GradientFun_2D
#'
#' @param SIZE_MU:SIZE_MU
#' @param m_observed: m_observed
#' @param BETA: BETA
#' @return GradientFun_2D
#' @export
GradientFun_2D <- function(SIZE_MU, m_observed, BETA) {
    .Call('_bayNorm_GradientFun_2D', PACKAGE = 'bayNorm', SIZE_MU, m_observed, BETA)
}

#' MarginalF_2D
#'
#' MarginalF_2D
#'
#' @param SIZE:SIZE
#' @param MU:MU
#' @param size: A vector of size
#' @param mu: A vector of mu
#' @param m_observed:m_observed
#' @param BETA:BETA
#' @return Marginal likelihood
#' @export
MarginalF_2D <- function(SIZE_MU, m_observed, BETA) {
    .Call('_bayNorm_MarginalF_2D', PACKAGE = 'bayNorm', SIZE_MU, m_observed, BETA)
}

#' GradientFun_1D
#'
#' GradientFun_1D
#'
#' @param SIZE:SIZE
#' @param MU:MU
#' @param m_observed: m_observed
#' @param BETA: BETA
#' @return GradientFun_1D
#' @export
GradientFun_1D <- function(SIZE, MU, m_observed, BETA) {
    .Call('_bayNorm_GradientFun_1D', PACKAGE = 'bayNorm', SIZE, MU, m_observed, BETA)
}

#' MarginalF_1D
#'
#' MarginalF_1D
#'
#' @param SIZE:SIZE
#' @param MU:MU
#' @param size: A vector of size
#' @param mu: A vector of mu
#' @param m_observed:m_observed
#' @param BETA:BETA
#' @return Marginal likelihood
#' @export
MarginalF_1D <- function(SIZE, MU, m_observed, BETA) {
    .Call('_bayNorm_MarginalF_1D', PACKAGE = 'bayNorm', SIZE, MU, m_observed, BETA)
}

#' Binomial downsampling
#'
#' For each element in the \code{Data}, randomly generate a number using Binomial distribution with probability equal to the specific capture efficiency.
#'
#'
#' @param Data: raw count Data
#' @param BETA_vec: A vector of capture efficiencies of cells
#' @return A matrix of binomial downsampling data.
#' @export
DownSampling <- function(Data, BETA_vec) {
    .Call('_bayNorm_DownSampling', PACKAGE = 'bayNorm', Data, BETA_vec)
}


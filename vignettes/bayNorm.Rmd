---
title: "Introduction to bayNorm"
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('bayNorm')`"
author: 
- name: Wenhao Tang
  email: wt215@ic.ac.uk
- name: Vahid Shahrezaei
  email: v.shahrezaei@imperial.ac.uk
  

output: 
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
    fig_width: 16
bibliography: library.bib
vignette: >
  %\VignetteIndexEntry{Introduction to bayNorm}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---

```{r, echo=FALSE, results="hide", message=FALSE}
require(knitr)
opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE, dpi = 30)
knitr::opts_chunk$set(dev="png",fig.align="center")
```

```{r library, echo=FALSE}
library(bayNorm)
library(BiocStyle)
```

# Installation
```{r install, eval=FALSE}
library(devtools)
devtools::install_github("WT215/bayNorm")
```




***


# Quick start: for either one or multi groups of cells
The main function is `bayNorm` which is a wrapper function of prior parameters estimation and normalized array or matrix generation. 

Essential parameters for running `bayNorm` are: 

* `Data`: a `SummarizedExperiment` object or matrix (rows: genes, columns: cells). 
* `BETA_vec`: a vector of probabilities which is of length equal to the number of cells. 
* `Conditions`: If `Conditions` is provided, prior parameters will be estimated within each group of cells (we name this kind of procedure as "LL" procedure where "LL" stands for estimating both $\mu$ and $\phi$ locally). Otherwise, bayNorm applied "GG" procedure for estimating prior parameters (estimating both $\mu$ and $\phi$ globally).
* `Prior_type`: Even if you have specified the `Conditions`, you can still choose to estimate prior parameters across all the cells by setting `Prior_type="GG"`.

***

## Estimation of capture efficiencies
Apart from the raw data, another parameter which user may need to provide is the mean capture efficiency $<\beta>$ and hence $\beta$ can be further calculated using scaling factors estimated from any other methods. The default $\beta$ is calculated to be total counts normalized to 6\%. Or you can use `BetaFun` in bayNorm to estimate $\beta$:
```{r beta, echo=TRUE,eval=TRUE}
data('EXAMPLE_DATA_list')
BETA_est<-BetaFun(Data=EXAMPLE_DATA_list$inputdata,MeanBETA=0.06)
summary(BETA_est$BETA)
```
The function `BetaFun` selects a subset of genes such that outlier genes and genes with high proportion of zeros across cells are excluded. Then the total counts of the subset of genes in each cell are normalized to $<\beta>$. Another way is to normalize scaling factors estimated from the R package `scran` to $<\beta>$.



## Run bayNorm
`BETA_vec` can be set to be `NULL`, then the $\beta$ are estimated to be total counts normalized to 6\%.
```{r intro_bayNorm, echo=TRUE,eval=FALSE}
data('EXAMPLE_DATA_list')
#Return 3D array normalzied data, draw 20 samples from posterior distribution:
bayNorm_3D<-bayNorm(
    Data=EXAMPLE_DATA_list$inputdata,
    BETA_vec = NULL,
    mode_version=F,
    mean_version = F,S=20)

#Return 2D matrix normalized data (MAP of posterior):
bayNorm_2D<-bayNorm(
    Data=EXAMPLE_DATA_list$inputdata,
    BETA_vec = NULL,
    mode_version=T,
    mean_version = F)

#Return 2D matrix normalized data (mean of posterior):
bayNorm_2D<-bayNorm(
    Data=EXAMPLE_DATA_list$inputdata,
    BETA_vec = NULL,
    mode_version=F,
    mean_version = T)
```



## Non-UMI scRNAseq dataset
bayNorm's mathematical model is suitable for UMI dataset. However it can be also applied on non-UMI dataset. In `bayNorm`, you need to specify the following parameter:
* `UMI_sffl`: bayNorm can also be applied on the non-UMI dataset. However, user need to provide a scaled number. Raw data will be divided by the scaled number and bayNorm will be applied on the rounded scaled data. By doing so, the Dropout vs Mean expression plots will be similar to that of UMI dataset.


## Generate 3D array or 2D matrix with existing estimated prior parameters.
If you have run bayNorm on a dataset before but want to output another kind of data (3D array or 2D matrix), you can use the function `bayNorm_sup`. It is important to input the existing estimated parameters by specifying the following parameter in `bayNorm_sup`:

* `BETA_vec`: If `Conditions` has been specified previously, then input `unlist(bayNorm_output$BETA)`
* `PRIORS`: `input bayNorm_output$PRIORS_LIST`
* `Conditions`: make sure to specify the same `Conditions` as before.
You can find these two objects from the previous output of bayNorm function, which is a list.

```{r intro_bayNorm_sup, echo=TRUE,eval=FALSE}
data('EXAMPLE_DATA_list')
#Return 3D array normalzied data:
bayNorm_3D<-bayNorm(
    Data=EXAMPLE_DATA_list$inputdata,
    BETA_vec = EXAMPLE_DATA_list$inputbeta,
    mode_version=F,
    mean_version = F)

#Now if you want to generate 2D matrix (MAP) using the same prior
#estimates as generated before:
bayNorm_2D<-bayNorm_p(
    Data=EXAMPLE_DATA_list$inputdata,
    BETA_vec= bayNorm_3D$BETA,
    PRIORS=bayNorm_3D$PRIORS_LIST,
    mode_version=T,
    mean_version = F)

#Or you may want to generate 2D matrix 
#(mean of posterior) using the same prior
#estimates as generated before:
bayNorm_2D<-bayNorm_p(
    Data=EXAMPLE_DATA_list$inputdata,
    BETA_vec= bayNorm_3D$BETA,
    PRIORS=bayNorm_3D$PRIORS_LIST,
    mode_version=F,
    mean_version = T)
```







***

# Session information

```{r SessionInfo}
sessionInfo()
```

***

# References



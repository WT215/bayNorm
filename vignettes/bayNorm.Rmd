---
title: "Introduction to bayNorm"
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('bayNorm')`"
author: 
- name: Wenhao Tang
  email: wt215@ic.ac.uk
- name: Fran<U+00E7>ois Bertaux
  email: f.bertaux@imperial.ac.uk
- name: Philipp Thomas
  email: p.thomas@imperial.ac.uk
- name: Claire Stefanelli
  email: c.stefanelli.v@gmail.com
- name: Malika Saint
  email: malikasaint@gmail.com
- name: Samuel Marguerat
  email: samuel.marguerat@lms.mrc.ac.uk
- name: Vahid Shahrezaei
  email: v.shahrezaei@imperial.ac.uk
  

output: 
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
    fig_width: 16
bibliography: library.bib
vignette: >
  %\VignetteIndexEntry{Introduction to bayNorm}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---

```{r, echo=FALSE, results="hide", message=FALSE}
require(knitr)
opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE, dpi = 30)
knitr::opts_chunk$set(dev="png",fig.align="center")
```

```{r library, echo=FALSE}
library(bayNorm)
library(BiocStyle)
library(SummarizedExperiment)
library(SingleCellExperiment)
```

# Installation


bayNorm has been submitted to Bioconductor, once it is accepted, it can be installed via:
```{r install_Bioconductor, eval=FALSE}
library(BiocManager)
BiocManager::install("bayNorm")
```

Currently bayNorm can be installed via github:
```{r install, eval=FALSE}
library(devtools)
devtools::install_github("WT215/bayNorm")
```




***


# Quick start: for either one or multi groups of cells
The main function is `bayNorm` which is a wrapper function of prior parameters estimation and normalized array or matrix generation. 

Essential parameters for running `bayNorm` are: 

* `Data`: a `SummarizedExperiment` object or matrix (rows: genes, columns: cells). 
* `BETA_vec`: a vector of probabilities which is of length equal to the number of cells. 
* `Conditions`: If `Conditions` is provided, prior parameters will be estimated within each group of cells (we name this kind of procedure as "LL" procedure where "LL" stands for estimating both $\mu$ and $\phi$ locally). Otherwise, bayNorm applied "GG" procedure for estimating prior parameters (estimating both $\mu$ and $\phi$ globally).
* `Prior_type`: Even if you have specified the `Conditions`, you can still choose to estimate prior parameters across all the cells by setting `Prior_type="GG"`.


The input parameters `BETA_vec`, `Conditions` (if specified), `UMI_sffl` (if specified), `Prior_type`, `FIX_MU`, `BB_SIZE` and `GR` are stored in the list `input_params` which should be output from `bayNorm`. Objects `PRIORS` together with `input_params` output from `bayNorm` should be input in `bayNorm_sup` for transforming between 3D array, mode or mean version's output of normalized count matricies.


## Output of bayNorm
![Output of bayNorm](E:/RNAseqProject/bayNorm_dev/bayNorm/vignettes/bayNorm_output.png)

bayNorm allows for three different types of normalized data as output. For more details, see [1](https://github.com/WT215/bayNorm_papercode)


***

## Estimation of capture efficiencies
Apart from the raw data, another parameter which user may need to provide is the mean capture efficiency $<\beta>$ and hence $\beta$ can be further calculated using scaling factors estimated from any other methods. The default $\beta$ is calculated to be total counts normalized to 6\%. Or you can use `BetaFun` in bayNorm to estimate $\beta$:
```{r beta, echo=TRUE,eval=TRUE}
data('EXAMPLE_DATA_list')
#Suppose the input data is a SummarizedExperiment object:
rse <- SummarizedExperiment::SummarizedExperiment(assays=SimpleList(counts=EXAMPLE_DATA_list$inputdata))
#SingleCellExperiment object can also be input in bayNorm:
#rse <- SingleCellExperiment::SingleCellExperiment(assays=list(counts=EXAMPLE_DATA_list$inputdata))

BETA_est<-BetaFun(Data=rse,MeanBETA=0.06)
summary(BETA_est$BETA)
```
The function `BetaFun` selects a subset of genes such that outlier genes and genes with high proportion of zeros across cells are excluded. Then the total counts of the subset of genes in each cell are normalized to $<\beta>$. Another way is to normalize scaling factors estimated from the R package `scran` to $<\beta>$.



## Run bayNorm
`BETA_vec` can be set to be `NULL`, then the $\beta$ are estimated to be total counts normalized to 6\%.
```{r intro_bayNorm, echo=FALSE,eval=TRUE}
#Return 3D array normalzied data, draw 20 samples from posterior distribution:
bayNorm_3D<-bayNorm(
    Data=rse,
    BETA_vec = NULL,
    mode_version=FALSE,
    mean_version = FALSE,S=20
    ,verbose =FALSE)

#Return 2D matrix normalized data (MAP of posterior):
bayNorm_2D<-bayNorm(
    Data=rse,
    BETA_vec = NULL,
    mode_version=TRUE,
    mean_version = FALSE
    ,verbose =FALSE)

#Return 2D matrix normalized data (mean of posterior):
bayNorm_2D<-bayNorm(
    Data=rse,
    BETA_vec = NULL,
    mode_version=FALSE,
    mean_version = TRUE
    ,verbose =FALSE)
```



## Non-UMI scRNAseq dataset
bayNorm's mathematical model is suitable for UMI dataset. However it can be also applied on non-UMI dataset. In `bayNorm`, you need to specify the following parameter:
* `UMI_sffl`: bayNorm can also be applied on the non-UMI dataset. However, user need to provide a scaled number. Raw data will be divided by the scaled number and bayNorm will be applied on the rounded scaled data. By doing so, the Dropout vs Mean expression plots will be similar to that of UMI dataset.


## Generate 3D array or 2D matrix with existing estimated prior parameters.
If you have run bayNorm on a dataset before but want to output another kind of data (3D array or 2D matrix), you can use the function `bayNorm_sup`. It is important to input the existing estimated parameters by specifying the following parameter in `bayNorm_sup`:

* `BETA_vec`: If `Conditions` has been specified previously, then input `unlist(bayNorm_output$BETA)`
* `PRIORS`: `input bayNorm_output$PRIORS_LIST`
* `Conditions`: make sure to specify the same `Conditions` as before.
You can find these two objects from the previous output of bayNorm function, which is a list.

```{r intro_bayNorm_sup, echo=FALSE,eval=TRUE}
data('EXAMPLE_DATA_list')


#Return 3D array normalzied data:
bayNorm_3D<-bayNorm(
    Data=rse,
    BETA_vec = EXAMPLE_DATA_list$inputbeta,
    mode_version=FALSE,
    mean_version = FALSE,
    verbose =FALSE)

#Now if you want to generate 2D matrix (MAP) using the same prior
#estimates as generated before:
bayNorm_2D<-bayNorm_sup(
    Data=rse,
    PRIORS=bayNorm_3D$PRIORS,
    input_params=bayNorm_3D$input_params,
    mode_version=TRUE,
    mean_version = FALSE,
    verbose =FALSE)

#Or you may want to generate 2D matrix 
#(mean of posterior) using the same prior
#estimates as generated before:
bayNorm_2D<-bayNorm_sup(
    Data=rse,
    PRIORS=bayNorm_3D$PRIORS,
    input_params=bayNorm_3D$input_params,
    mode_version=FALSE,
    mean_version = TRUE,
    verbose =FALSE)
```







***

# Session information

```{r SessionInfo}
sessionInfo()
```

***

# References

- [1] <a href="https://www.biorxiv.org/content/early/2018/08/03/384586">Tang <em>et al.</em> (2018). bioRxiv. </a>
